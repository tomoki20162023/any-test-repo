# gitの基本知識を再確認する

## リポジトリの種類

- リモートリポジトリ : 複数人で共有するためのリポジトリ
- ローカルリポジトリ : ユーザ一人ひとりが利用するために、手元のマシン上に配置するリポジトリ

## データの移動

- プル(pull) : **リモート**リポジトリから**ローカル**リポジトリへデータを*ダウンロード*する
- プッシュ(push) : **ローカル**リポジトリから**リモート**リポジトリへデータを*アップロード*する

## リポジトリの作成

- 新規作成(init)
- リモートリポジトリをコピーする(clone)

## 記録

- コミット(commit) : リポジトリの内容物（ファイル、ディレクトリ）に変更（追加、修正、削除）があった場合にそれを記録しておく操作
- コミットは変更の差分を記録するため、コミットを辿ることで変更履歴とその内容を知ることができる
- コミットには英数字40桁の追加データ（ハッシュ？）が付けられている
- コミットには追加のメッセージ（コミットメッセージが付けられる

## 構成

- ワークツリー : gitの管理下にあるディレクトリ
- インデックス : リポジトリとワークツリーの管理を仲介しているファイル
	- コミットするコンテンツをインデックスに登録し、インデックスからリポジトリの管理物として記録される


## ブランチ

- 変更履歴を分岐して記録していくための機能
- リポジトリの作成直後はmasterがデフォルトブランチになっている
- ブランチ間は変更の影響を受けないため、目的ごとにブランチを作成するのが一般的
- コミットすると、ローカルリポジトリにある現在参照しているブランチに記録される
- 他のブランチの変更を取り込むにはマージ(merge)する
- ブランチが複数あるときに、作業するブランチを切り替えるにはチェックアウト(checkout)を行う
	- checkoutを行うと、切り替えた先のブランチで最後にcommitした変更履歴がワークツリーに展開される
- HEADが現在作業中にブランチの先頭を表す
	- デフォルトではmasterブランチの先頭になっている


## プッシュ

- ローカルリポジトリの変更内容をリモートリポジトリと共有する方法
- ブランチは同じ

## クローン

- リモートリポジトリの内容をまるごとローカルリポジトリとしてコピーする操作
- 変更履歴もコピーされるので、履歴の参照は追加のコミットも問題なくできる
- 手元で変更を加えることができる

## プル

- 複数人でリモートリポジトリを共有しながら作業する場合、他の人がリモートリポジトリにプッシュした変更内容を取り込む必要が出てくる
- pullをすることでリモートリポジトリにある変更内容を、ローカルリポジトリに取り込むことができる

## リモートリポジトリの名前

- pushやpullの実行時にリモートリポジトリを指定しない場合が多い（？）
- このとき、自動的に目的のリモートリポジトリを対象として捜査が実行されているのはなぜか？
- 既定ではリモートリポジトリの名前はoriginと付けられている
	- 省略せずに色々な名前で試してみるのも、理解に繋がるはず
	- 名前を付けるということは、ローカルリポジトリの環境で閉じているはず
	- 理解しやすい名前を付けて管理するのも、一つの管理ポリシーとしてありだと思う

- コミットの位置
	- origin/master : リモートリポジトリ[origin]のブランチ[master]を表している
	- origin/HEAD : リモートリポジトリ[origin]からクローンしたときに共有されるコミットの位置。通常はorigin/masterと同じ位置を表す
	- master : ローカルリポジトリのブランチ[master]を表す

## マージ(merge)

- リモートリポジトリの変更履歴が他のユーザによって先に変更されているケースがある
	- 変更内容によっては自動的に統合（マージ）できる場合もある
	- 一方で、リモートリポジトリの変更内容と取り込むまで、ローカルリポジトリからpushできない場合もある（競合状態の発生）
		- リモートリポジトリとローカルリポジトリで同じ個所を修正していた場合は手動で修正してマージする必要がある
		- まずはpullして、ローカルリポジトリに修正内容を追加する
		- この時は自動マージに失敗して、エラーメッセージが出る
		- 変更内容を確認して、競合状態を解消するように修正する
		- 競合状態を解消してコミットしたあとであれば、pushできるようになっている
- マージの方法
	- masterブランチからbugfixブランチを分岐させた場合
		- bugfixがmasterの変更履歴を全て持っている場合は
			- 単純にmasterブランチを先頭をbugfixブランチの先頭に移動させればよい(fast-forwardマージと呼ぶ)
		- masterの変更履歴が、bugfixを分岐したときより進んでいる場合
			- 両方の変更を取り込む必要があり、masterブランチで新しいコミットが作成され、両方の変更が取り込まれたマージコミットとなる。masterの先頭もそこに移動する
			- fast-forwardマージが可能な場合でも、コマンドオプション(non fast-forward)によりマージコミットを作成できる
				- ブランチがそのまま残るので、そのブランチで行った作業が分かりやすくなる

## リベース(rebase)

- リベースの方法
	- masterブランチからbugfixブランチを分岐させ、masterブランチも進んでいる場合
		- bugfixの変更履歴全てが、masterの後ろに一本化されて統合される
			- bugfixの先頭は統合された変更履歴の先頭になる
			- 統合されるbugfixのそれぞれのコミットで競合が発生する可能性がある
			- その時は発生した競合を全て解消していく必要がある
		- bugfixの変更内容が変わることがあるため、統合したあとにbugfixの元の変更内容が動かない可能性が出てくる
		- リベースして競合も無くなったあと
			- masterの先頭がそのままなので、マージしてfast-forwardすることで、masterの先頭がbugfixと同じになる

- リベースの運用
	- 別のブランチの変更内容を取り込むときにリベースが必要なこともある
		- 例えば、分岐元のブランチがバグ修正のコミットをマージした場合
			- 作業中のブランチにおいて、その変更内容が必要なとき、リベースすることで分岐元のブランチの先頭から分岐した状態に更新することができる

'''
リベース前）
	A -> B -> C
		 |--> X

リベース後）
	A -> B -> C
			  |--> X'
  ここからX'をマージして、fast-forwardするかは運用中の選択次第

'''


## stash

- 変更内容を一時的に退避させておく機能
	- 変更内容をコミットしないまま他のブランチにチェックアウトしようとして、競合が発生するとチェックアウトに失敗する
		- 競合が発生しなかった場合は、変更内容がチェックアウト先のブランチに反映されてしまう。
	- このときは現在のブランチでコミットするか、stashで変更内容を退避させてからチェックアウトしなければならない
	- どういう状態か。
		- ワークツリーの変更がインデックスに反映されていない状態
		- インデックスに追加された変更が、コミットされていない状態

## ブランチの運用方法

### デファクト？


- メインブランチ
	- master : リリース専用ブランチ。リリースバージョンのタグを付けて管理する
	- develop : 開発用ブランチ。主にここで開発内容を管理・統合する。
- フィーチャーブランチ（トピックブランチ）
	- 新機能の開発
	- バグ修正
- リリースブランチ
	- リリース準備用のブランチ
	- リリース前の最終調整などを行い、masterブランチにマージしてリリースする
	- また、同時にdevelopブランチにもリリース内容を反映させるためにマージする
- ホットフィックスブランチ
	- 緊急のバグ修正用
	- マイナーバージョンアップ
	- このブランチもdevelopブランチに取り込む


